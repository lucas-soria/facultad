{"ast":null,"code":"'use strict';\n\nvar SymbolNode = require('mr-parser').nodeTypes.SymbolNode;\n\nvar functionProxy = function functionProxy(node) {\n  return '$$mathCodegen.functionProxy(' + this.next(new SymbolNode(node.name)) + ', \"' + node.name + '\")';\n};\n\nmodule.exports = function (node) {\n  var self = this; // wrap in a helper function to detect the type of symbol it must be a function\n  // NOTE: if successful the wrapper returns the function itself\n  // NOTE: node.name should be a symbol so that it's correctly represented as a string in SymbolNode\n\n  var method = functionProxy.call(this, node);\n  var args = [];\n  this.rawify(this.options.rawCallExpressionElements, function () {\n    args = node.args.map(function (arg) {\n      return self.next(arg);\n    });\n  });\n  return method + '(' + args.join(', ') + ')';\n};\n\nmodule.exports.functionProxy = functionProxy;","map":{"version":3,"sources":["/mnt/sda3/Lucas/Documents/facultad/5° Año/1° Semestre/Modelos y simulaciones/Mario Molina Estocastica/plotting/node_modules/math-codegen/lib/node/FunctionNode.js"],"names":["SymbolNode","require","nodeTypes","functionProxy","node","next","name","module","exports","self","method","call","args","rawify","options","rawCallExpressionElements","map","arg","join"],"mappings":"AAAA;;AACA,IAAIA,UAAU,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,SAArB,CAA+BF,UAAhD;;AAEA,IAAIG,aAAa,GAAG,SAAhBA,aAAgB,CAAUC,IAAV,EAAgB;AAClC,SAAO,iCAAiC,KAAKC,IAAL,CAAU,IAAIL,UAAJ,CAAeI,IAAI,CAACE,IAApB,CAAV,CAAjC,GAAwE,KAAxE,GAAgFF,IAAI,CAACE,IAArF,GAA4F,IAAnG;AACD,CAFD;;AAIAC,MAAM,CAACC,OAAP,GAAiB,UAAUJ,IAAV,EAAgB;AAC/B,MAAIK,IAAI,GAAG,IAAX,CAD+B,CAE/B;AACA;AACA;;AACA,MAAIC,MAAM,GAAGP,aAAa,CAACQ,IAAd,CAAmB,IAAnB,EAAyBP,IAAzB,CAAb;AACA,MAAIQ,IAAI,GAAG,EAAX;AACA,OAAKC,MAAL,CAAY,KAAKC,OAAL,CAAaC,yBAAzB,EAAoD,YAAY;AAC9DH,IAAAA,IAAI,GAAGR,IAAI,CAACQ,IAAL,CAAUI,GAAV,CAAc,UAAUC,GAAV,EAAe;AAClC,aAAOR,IAAI,CAACJ,IAAL,CAAUY,GAAV,CAAP;AACD,KAFM,CAAP;AAGD,GAJD;AAKA,SAAOP,MAAM,GAAG,GAAT,GAAeE,IAAI,CAACM,IAAL,CAAU,IAAV,CAAf,GAAiC,GAAxC;AACD,CAbD;;AAeAX,MAAM,CAACC,OAAP,CAAeL,aAAf,GAA+BA,aAA/B","sourcesContent":["'use strict'\nvar SymbolNode = require('mr-parser').nodeTypes.SymbolNode\n\nvar functionProxy = function (node) {\n  return '$$mathCodegen.functionProxy(' + this.next(new SymbolNode(node.name)) + ', \"' + node.name + '\")'\n}\n\nmodule.exports = function (node) {\n  var self = this\n  // wrap in a helper function to detect the type of symbol it must be a function\n  // NOTE: if successful the wrapper returns the function itself\n  // NOTE: node.name should be a symbol so that it's correctly represented as a string in SymbolNode\n  var method = functionProxy.call(this, node)\n  var args = []\n  this.rawify(this.options.rawCallExpressionElements, function () {\n    args = node.args.map(function (arg) {\n      return self.next(arg)\n    })\n  })\n  return method + '(' + args.join(', ') + ')'\n}\n\nmodule.exports.functionProxy = functionProxy\n"]},"metadata":{},"sourceType":"script"}